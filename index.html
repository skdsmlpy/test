<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic Cricket Score Display</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 10px;
      line-height: 1.4;
      color: #333;
      font-size: 14px;
    }

    h3 {
      color: #2c3e50;
      margin-top: 10px;
      margin-bottom: 10px;
      font-size: 16px;
    }

    .container {
      display: flex;
      width: 100%;
    }

    .scores-panel {
      width: 40%;
      padding-right: 10px;
    }

    .ball-by-ball-panel {
      width: 60%;
      border-left: 1px solid #ddd;
      padding-left: 10px;
      height: 600px;
      overflow-y: auto;
    }

    /* Team header styles */
    .team-header {
      display: flex;
      margin-bottom: 15px;
    }

    .batting-team, .bowling-team {
      flex: 1;
      padding: 10px;
      background-color: #f0f0f0;
      color: #333;
      text-align: center;
      font-weight: bold;
      font-size: 16px;
    }

    .batting-team {
      border-right: 1px solid white;
      border-top-left-radius: 4px;
      border-bottom-left-radius: 4px;
    }

    .bowling-team {
      border-top-right-radius: 4px;
      border-bottom-right-radius: 4px;
    }

    /* Score banner styles */
    .score-banner {
      display: flex;
      background: linear-gradient(to right, #f8f9fa, #2c3e73);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 10px;
      color: white;
      height: 60px;
    }

    .batter-left, .batter-right {
      width: 25%;
      padding: 5px 10px;
      background-color: #f0f0f0;
      color: #333;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .team-score {
      width: 50%;
      background-color: #2c3e73;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: bold;
    }

    .bat-icon {
      display: inline-block;
      margin-right: 6px;
      width: 16px;
      height: 16px;
      background-color: #8B4513; /* Brown color for bat */
      position: relative;
    }

    .bat-icon::before {
      content: "";
      position: absolute;
      top: -3px;
      left: 6px;
      width: 4px;
      height: 10px;
      background-color: #8B4513;
    }

    .bat-icon.active {
      background-color: #e67e22; /* Orange color for active bat */
    }

    .bat-icon.active::before {
      background-color: #e67e22;
    }

    /* Table styles */
    .info-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 15px;
    }

    .info-table th, .info-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }

    .info-table th {
      background-color: #f2f2f2;
    }

    /* Ball by ball section */
    .ball-by-ball {
      margin-top: 10px;
    }

    .ball-entry {
      padding: 6px;
      border-bottom: 1px solid #eee;
      position: relative;
      font-size: 13px;
    }

    .ball-entry:nth-child(odd) {
      background-color: #f9f9f9;
    }

    .ball-number {
      font-weight: bold;
      margin-right: 5px;
      background-color: #3498db;
      color: white;
      padding: 2px 5px;
      border-radius: 10px;
      font-size: 12px;
      display: inline-block;
      min-width: 30px;
      text-align: center;
    }

    .ball-runs {
      font-weight: bold;
      margin-right: 5px;
      background-color: #e67e22;
      color: white;
      padding: 2px 5px;
      border-radius: 10px;
      font-size: 12px;
      min-width: 15px;
      text-align: center;
      display: inline-block;
    }

    .ball-runs.boundary {
      background-color: #27ae60;
    }

    .ball-runs.six {
      background-color: #8e44ad;
    }

    .ball-runs.wicket {
      background-color: #c0392b;
    }

    .loading {
      text-align: center;
      padding: 20px;
      font-style: italic;
      color: #777;
    }

    /* Responsive styles */
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .scores-panel, .ball-by-ball-panel {
        width: 100%;
        padding: 0;
        border-left: none;
      }

      .ball-by-ball-panel {
        border-top: 1px solid #ddd;
        margin-top: 10px;
        padding-top: 10px;
        height: auto;
        max-height: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="scoreContent" class="scores-panel">
      <div id="loading" class="loading">Loading match details...</div>
    </div>
    <div class="ball-by-ball-panel">
      <h3>Ball By Ball Commentary</h3>
      <div class="ball-by-ball" id="ballByBallContainer">
        <div class="loading">Loading ball-by-ball commentary...</div>
      </div>
    </div>
  </div>

  <script>
    // Constants and configuration
    const PROXY_URL = 'https://api.allorigins.win/raw?url=';
    const CLUB_ID = 862;
    let MATCH_ID = 675; // Default match ID, can be changed

    // Main function to fetch and process cricket data
    async function loadMatchData() {
      try {
        document.getElementById('loading').innerHTML = '<div class="loading">Loading match details...</div>';
        document.getElementById('ballByBallContainer').innerHTML = '<div class="loading">Loading ball-by-ball commentary...</div>';

        // Create the target URL
        const targetUrl = `https://cricclubs.com/FT20/ballbyball.do?matchId=${MATCH_ID}&clubId=${CLUB_ID}`;
        const encodedTargetUrl = encodeURIComponent(targetUrl);
        const fullUrl = PROXY_URL + encodedTargetUrl;

        // Fetch data
        const response = await fetch(fullUrl);

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const html = await response.text();

        // Process the HTML to extract data
        processMatchData(html);
      } catch (error) {
        console.error('Error loading match data:', error);
        document.getElementById('loading').innerHTML = `<div class="loading">Error: ${error.message}</div>`;
      }
    }

    // Process the HTML to extract match data
    function processMatchData(html) {
      // Parse the HTML
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');

      // Extract team names
      const battingTeam = extractBattingTeam(doc);
      const bowlingTeam = extractBowlingTeam(doc);

      // Extract current score
      const currentScore = extractCurrentScore(doc);
      const currentOvers = extractCurrentOvers(doc);

      // Extract batsmen information - this is the key improvement
      const batsmen = extractBatsmen(doc);

      // Extract bowler information
      const currentBowler = extractCurrentBowler(doc);

      // Extract ball-by-ball commentary
      const ballByBall = extractBallByBall(doc);

      // Update the UI
      updateUI(battingTeam, bowlingTeam, currentScore, currentOvers, batsmen, currentBowler, ballByBall);
    }

    // Extract batting team from HTML
    function extractBattingTeam(doc) {
      const teamElements = doc.querySelectorAll('.teamName');
      if (teamElements && teamElements.length > 0) {
        return teamElements[0].textContent.trim();
      }
      return "ICAT"; // Default value
    }

    // Extract bowling team from HTML
    function extractBowlingTeam(doc) {
      const teamElements = doc.querySelectorAll('.teamName');
      if (teamElements && teamElements.length > 1) {
        return teamElements[1].textContent.trim();
      }
      return "ICAT A"; // Default value
    }

    // Extract current score from HTML
    function extractCurrentScore(doc) {
      const scoreElements = doc.querySelectorAll('.win span, .lose span');
      for (const el of scoreElements) {
        if (!el.classList.contains('teamName')) {
          const scoreText = el.textContent.trim();
          if (scoreText.includes('/')) {
            return scoreText;
          }
        }
      }
      return "0/0"; // Default value
    }

    // Extract current overs from HTML
    function extractCurrentOvers(doc) {
      const overElements = doc.querySelectorAll('.win p, .lose p');
      for (const el of overElements) {
        const oversText = el.textContent.trim();
        if (oversText.includes('ov') || oversText.includes('Overs')) {
          return oversText;
        }
      }
      return "0.0 overs"; // Default value
    }

    // Extract batsmen information - IMPROVED to dynamically find current batters
    function extractBatsmen(doc) {
      // First try to get batsmen from the specific batter table
      const batsmen = [];
      const bowlers = new Set(); // Track bowlers to avoid including them

      // Get the bowlers first so we can exclude them from batters
      const bowlerTables = doc.querySelectorAll('table');
      for (const table of bowlerTables) {
        // Check if this might be a bowling table by looking for headers like "O", "M", "W"
        const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent.trim());
        const isBowlingTable = headers.some(h => h === 'O' || h === 'W' || h === 'Econ' || h === 'M');

        if (isBowlingTable) {
          const rows = table.querySelectorAll('tbody tr');
          for (const row of rows) {
            const cells = row.querySelectorAll('th, td');
            if (cells.length >= 2) {
              const nameCell = cells[0];
              if (nameCell) {
                const playerLink = nameCell.querySelector('a');
                const bowlerName = playerLink ? playerLink.textContent.trim() : nameCell.textContent.trim();
                bowlers.add(bowlerName.toLowerCase());
              }
            }
          }
        }
      }

      // Method 1: Look for dedicated batsmen tables - most reliable source
      const batsmanTables = doc.querySelectorAll('.about-table');
      let foundBatters = false;

      for (const table of batsmanTables) {
        // Check if this is a batting table by looking for column headers
        const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent.trim());
        const isBattingTable = headers.some(h => h === 'Batter' || h === 'R' || h === 'B' || h === 'SR' || h === '4s' || h === '6s');

        if (isBattingTable) {
          const rows = table.querySelectorAll('tbody tr');
          for (const row of rows) {
            const cells = row.querySelectorAll('th');
            if (cells.length >= 3) {
              const playerLink = cells[0].querySelector('a');
              if (playerLink) {
                const name = playerLink.textContent.trim();
                // Skip this player if they're in the bowlers list
                if (bowlers.has(name.toLowerCase())) continue;

                const runs = cells[1].textContent.trim();
                const balls = cells[2].textContent.trim();

                // Check if this batter is marked as strong (striker)
                const isStriker = cells[0].innerHTML.includes('strong') ||
                                  cells[1].innerHTML.includes('strong');

                batsmen.push({
                  name: name,
                  runs: runs,
                  balls: balls,
                  isStriker: isStriker
                });
                foundBatters = true;
              }
            }
          }
        }
      }

      // If we found batters in the dedicated tables, we're done
      if (foundBatters) {
        // Make sure at least one is marked as striker
        if (batsmen.length > 0 && !batsmen.some(b => b.isStriker)) {
          batsmen[0].isStriker = true;
        }
        return batsmen;
      }

      // Method 2: Look through generic tables for batter information
      const allTables = doc.querySelectorAll('table');

      for (const table of allTables) {
        const rows = table.querySelectorAll('tr');

        for (const row of rows) {
          const cells = row.querySelectorAll('th, td');
          if (cells.length >= 3) {
            // Try to find player information in the row
            let nameCell = null;
            let runsCell = null;
            let ballsCell = null;

            // Look for a cell with a link to a player
            for (let i = 0; i < cells.length; i++) {
              const cell = cells[i];
              if (cell.querySelector('a[href*="viewPlayer.do"]')) {
                nameCell = cell;
                // Typically runs and balls are in the next cells
                runsCell = cells[i + 1] || null;
                ballsCell = cells[i + 2] || null;
                break;
              }
            }

            if (nameCell && runsCell) {
              const playerLink = nameCell.querySelector('a');
              if (playerLink) {
                const name = playerLink.textContent.trim();
                // Skip this player if they're in the bowlers list
                if (bowlers.has(name.toLowerCase())) continue;

                const runs = runsCell.textContent.trim();
                const balls = ballsCell ? ballsCell.textContent.trim() : '0';

                // Determine if this is the striker (current batter)
                const isStriker = nameCell.innerHTML.includes('strong') ||
                                 runsCell.innerHTML.includes('strong') ||
                                 row.textContent.includes('not out') ||
                                 row.textContent.includes('*');

                batsmen.push({
                  name: name,
                  runs: runs,
                  balls: balls,
                  isStriker: isStriker
                });
              }
            }
          }
        }
      }

      // Method 3: Check ball-by-ball commentary to find batsmen names
      if (batsmen.length === 0) {
        const commentaryElements = doc.querySelectorAll('.bbb-row .col3');
        const batsmenNames = new Set();
        const bowlerNames = new Set();

        for (const commentary of commentaryElements) {
          const text = commentary.textContent;

          // Extract bowler names to exclude them
          const bowlerMatch = text.match(/^([A-Za-z\s\.]+)\s+to\s+/i);
          if (bowlerMatch && bowlerMatch[1]) {
            bowlerNames.add(bowlerMatch[1].trim().toLowerCase());
          }

          // Extract batsman names
          const batsmanMatch = text.match(/to\s+([A-Za-z\s\.]+),/i);
          if (batsmanMatch && batsmanMatch[1]) {
            batsmenNames.add(batsmanMatch[1].trim());
          }
        }

        // Remove any names that are also in the bowlers list
        batsmenNames.forEach(name => {
          if (bowlerNames.has(name.toLowerCase())) {
            batsmenNames.delete(name);
          }
        });

        // Convert found names to batsmen objects
        let isFirst = true;
        batsmenNames.forEach(name => {
          batsmen.push({
            name: name,
            runs: '?',
            balls: '?',
            isStriker: isFirst // Assume first found is striker
          });
          isFirst = false;
        });
      }

      // Method 4: If still no batsmen found, check for batsmen mentioned in "comes to the crease" comments
      if (batsmen.length === 0) {
        const commentaryElements = doc.querySelectorAll('.bbb-row .col3');

        for (const commentary of commentaryElements) {
          const text = commentary.textContent;

          // Look for "comes to the crease" or similar phrases
          const newBatterMatch = text.match(/([A-Za-z\s\.]+),\s+comes to the crease/i);
          if (newBatterMatch && newBatterMatch[1]) {
            const batterName = newBatterMatch[1].trim();

            // Skip this player if they're in the bowlers list
            if (bowlers.has(batterName.toLowerCase())) continue;

            batsmen.push({
              name: batterName,
              runs: '?',
              balls: '?',
              isStriker: batsmen.length === 0 // First one is striker
            });

            // Only get the first two batters
            if (batsmen.length >= 2) break;
          }
        }
      }

      // Method 5: Check the full page text for batters with runs
      if (batsmen.length < 2) {
        const allText = doc.body.textContent;
        const battingPattern = /([A-Za-z\s\.]+)\s*(\d+)\s*\(\s*(\d+)\s*\)/g;
        let match;

        while ((match = battingPattern.exec(allText)) !== null) {
          const name = match[1].trim();
          // Skip this player if they're in the bowlers list
          if (bowlers.has(name.toLowerCase())) continue;

          const runs = match[2];
          const balls = match[3];

          // Check if this batter is already in our list
          const existingBatter = batsmen.find(b => b.name.toLowerCase() === name.toLowerCase());
          if (existingBatter) {
            // Update the existing batter's information
            existingBatter.runs = runs;
            existingBatter.balls = balls;
          } else {
            batsmen.push({
              name: name,
              runs: runs,
              balls: balls,
              isStriker: batsmen.length === 0 // First match is striker
            });
          }

          // Only get up to two batters
          if (batsmen.length >= 2) break;
        }
      }

      // If still no or incomplete batters found, use placeholder values
      if (batsmen.length === 0) {
        batsmen.push({
          name: "Current Batter",
          runs: "?",
          balls: "?",
          isStriker: true
        });

        batsmen.push({
          name: "Non-striker",
          runs: "?",
          balls: "?",
          isStriker: false
        });
      } else if (batsmen.length === 1) {
        batsmen.push({
          name: "Non-striker",
          runs: "?",
          balls: "?",
          isStriker: false
        });
      }

      // Make sure at least one batter is marked as striker
      if (batsmen.length > 0 && !batsmen.some(b => b.isStriker)) {
        batsmen[0].isStriker = true;
      }

      return batsmen;
    }

    // Extract current bowler information - improved to find actual current bowler
    function extractCurrentBowler(doc) {
      // Try to find the current active bowler from bowling tables first
      const allTables = doc.querySelectorAll('table');

      // Method 1: Look for dedicated bowler tables
      for (const table of allTables) {
        // Check if this is likely a bowling table
        const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent.trim());
        const isBowlingTable = headers.some(h => h === 'O' || h === 'W' || h === 'Econ' || h === 'Bowler');

        if (isBowlingTable) {
          const rows = table.querySelectorAll('tbody tr');
          // First row is likely the current bowler
          if (rows.length > 0) {
            const firstRow = rows[0];
            const cells = firstRow.querySelectorAll('th, td');

            if (cells.length >= 5) {
              const nameCell = cells[0];
              if (nameCell) {
                const playerLink = nameCell.querySelector('a');
                const name = playerLink ? playerLink.textContent.trim() : nameCell.textContent.trim();

                return {
                  name: name,
                  overs: cells.length > 1 ? cells[1].textContent.trim() : "?",
                  maidens: cells.length > 2 ? cells[2].textContent.trim() : "0",
                  runs: cells.length > 3 ? cells[3].textContent.trim() : "?",
                  wickets: cells.length > 4 ? cells[4].textContent.trim() : "0",
                  economy: cells.length > 5 ? cells[5].textContent.trim() : "?"
                };
              }
            }
          }
        }
      }

      // Method 2: Try to find bowler from recent commentary
      const commentaryElements = doc.querySelectorAll('.bbb-row .col3');

      for (const commentary of commentaryElements) {
        const text = commentary.textContent;

        // Look for patterns like "Bowler to Batsman"
        const bowlerMatch = text.match(/^([A-Za-z\s\.]+)\s+to\s+/i);
        if (bowlerMatch && bowlerMatch[1]) {
          const bowlerName = bowlerMatch[1].trim();

          // Try to find this bowler's stats in the bowling tables
          for (const table of allTables) {
            const rows = table.querySelectorAll('tr');
            for (const row of rows) {
              const cells = row.querySelectorAll('th, td');
              if (cells.length >= 5) {
                const nameCell = cells[0];
                if (nameCell) {
                  const name = nameCell.textContent.trim();
                  if (name.toLowerCase().includes(bowlerName.toLowerCase())) {
                    return {
                      name: bowlerName,
                      overs: cells.length > 1 ? cells[1].textContent.trim() : "?",
                      maidens: cells.length > 2 ? cells[2].textContent.trim() : "0",
                      runs: cells.length > 3 ? cells[3].textContent.trim() : "?",
                      wickets: cells.length > 4 ? cells[4].textContent.trim() : "0",
                      economy: cells.length > 5 ? cells[5].textContent.trim() : "?"
                    };
                  }
                }
              }
            }
          }

          // If we couldn't find full stats, return what we know
          return {
            name: bowlerName,
            overs: "?",
            maidens: "0",
            runs: "?",
            wickets: "0",
            economy: "?"
          };
        }
      }

      // Method 3: Look for "comes into the attack" text in commentary
      for (const commentary of commentaryElements) {
        const text = commentary.textContent;

        // Look for patterns indicating a new bowler
        const newBowlerMatch = text.match(/([A-Za-z\s\.]+),\s+comes into (the attack|the bowling)/i) ||
                              text.match(/([A-Za-z\s\.]+)\s+comes? (?:in)?to bowl/i);

        if (newBowlerMatch && newBowlerMatch[1]) {
          return {
            name: newBowlerMatch[1].trim(),
            overs: "0.0",
            maidens: "0",
            runs: "0",
            wickets: "0",
            economy: "0.00"
          };
        }
      }

      // Default bowler info if not found
      return {
        name: "Current Bowler",
        overs: "0.0",
        maidens: "0",
        runs: "0",
        wickets: "0",
        economy: "0.00"
      };
    }

    // Extract ball-by-ball commentary
    function extractBallByBall(doc) {
      const ballByBall = [];

      // Try to find the ball-by-ball section
      const ballEntries = doc.querySelectorAll('.bbb-row');

      if (ballEntries && ballEntries.length > 0) {
        ballEntries.forEach(entry => {
          const ballNumberEl = entry.querySelector('.ov');
          const runsEl = entry.querySelector('.runs');
          const commentaryEl = entry.querySelector('.col3');

          if (commentaryEl) {
            const commentary = commentaryEl.innerHTML.trim();
            const ballNumber = ballNumberEl ? ballNumberEl.textContent.trim() : '';
            const runs = runsEl ? runsEl.textContent.trim() : '';

            ballByBall.push({
              ball: ballNumber,
              runs: runs,
              commentary: commentary
            });
          }
        });
      }

      return ballByBall;
    }

    // Update the UI with extracted data
    function updateUI(battingTeam, bowlingTeam, currentScore, currentOvers, batsmen, currentBowler, ballByBall) {
      // Get a reference to the container
      const scoreContent = document.getElementById('scoreContent');

      // Create team header
      const teamHeader = `
        <div class="team-header">
          <div class="batting-team">${battingTeam}</div>
          <div class="bowling-team">${bowlingTeam}</div>
        </div>
      `;

      // Create score banner
      let scoreBanner = '';

      // Ensure we have batsmen data
      const striker = batsmen.find(b => b.isStriker) || { name: "?", runs: "?", balls: "?" };
      const nonStriker = batsmen.find(b => !b.isStriker) || { name: "?", runs: "?", balls: "?" };

      scoreBanner = `
        <div class="score-banner">
          <div class="batter-left">
            <div class="bat-icon active"></div>
            ${striker.name} (${striker.balls})
          </div>
          <div class="team-score">
            ${currentScore} - ${currentOvers}
          </div>
          <div class="batter-right">
            ${nonStriker.name} (${nonStriker.balls})
          </div>
        </div>
      `;

      // Create batsmen table
      let batsmenTable = `
        <h3>Current Batters</h3>
        <table class="info-table">
          <thead>
            <tr>
              <th>Batter</th>
              <th>Runs</th>
              <th>Balls</th>
              <th>SR</th>
            </tr>
          </thead>
          <tbody>
      `;

      batsmen.forEach(batsman => {
        const strikeRate = calculateStrikeRate(batsman.runs, batsman.balls);
        batsmenTable += `
          <tr>
            <td>
              <div class="bat-icon ${batsman.isStriker ? 'active' : ''}"></div>
              ${batsman.name}${batsman.isStriker ? ' *' : ''}
            </td>
            <td>${batsman.runs}</td>
            <td>${batsman.balls}</td>
            <td>${strikeRate}</td>
          </tr>
        `;
      });

      batsmenTable += `
          </tbody>
        </table>
      `;

      // Create bowler table
      const bowlerTable = `
        <h3>Current Bowler</h3>
        <table class="info-table">
          <thead>
            <tr>
              <th>Bowler</th>
              <th>O</th>
              <th>M</th>
              <th>R</th>
              <th>W</th>
              <th>Econ</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>${currentBowler.name}</td>
              <td>${currentBowler.overs}</td>
              <td>${currentBowler.maidens}</td>
              <td>${currentBowler.runs}</td>
              <td>${currentBowler.wickets}</td>
              <td>${currentBowler.economy}</td>
            </tr>
          </tbody>
        </table>
      `;

      // Update the score content
      scoreContent.innerHTML = teamHeader + scoreBanner + batsmenTable + bowlerTable;

      // Update ball-by-ball commentary
      updateBallByBall(ballByBall);
    }

    // Update the ball-by-ball container
    function updateBallByBall(ballByBall) {
      const container = document.getElementById('ballByBallContainer');

      if (ballByBall.length > 0) {
        let html = '';

        ballByBall.forEach(ball => {
          const runClass = ball.runs === '4' ? 'boundary' :
                           ball.runs === '6' ? 'six' :
                           ball.runs === 'W' ? 'wicket' : '';

          html += `
            <div class="ball-entry">
              ${ball.ball ? `<span class="ball-number">${ball.ball}</span>` : ''}
              ${ball.runs ? `<span class="ball-runs ${runClass}">${ball.runs}</span>` : ''}
              <span class="ball-commentary">${ball.commentary}</span>
            </div>
          `;
        });

        container.innerHTML = html;
      } else {
        container.innerHTML = '<div class="loading">No ball-by-ball data available</div>';
      }
    }

    // Helper function to calculate strike rate
    function calculateStrikeRate(runs, balls) {
      const runsNum = parseInt(runs);
      const ballsNum = parseInt(balls);

      if (isNaN(runsNum) || isNaN(ballsNum) || ballsNum === 0) {
        return "0.00";
      }

      const sr = (runsNum / ballsNum) * 100;
      return sr.toFixed(2);
    }

    // Load the match data when the page loads
    window.addEventListener('DOMContentLoaded', loadMatchData);
  </script>
</body>
</html>
